class WhaleOptimizationAlgorithm:
    def __init__(self, num_hubs, num_nodes, num_backup_hubs, num_time_periods,
                 hub_capacities, node_hub_times, hub_hub_times, backup_hub_startup_times,
                 hub_establishment_costs, hub_maintenance_costs, hub_repair_costs,
                 hub_deactivation_costs, rerouting_costs, backup_hub_startup_costs,
                 backup_hub_maintenance_costs, hub_failure_probability,
                 node_demands, inter_hub_flow, M,
                 population_size, max_iterations, weight_z1, weight_z2):

        self.NUM_HUBS = num_hubs
        self.NUM_NODES = num_nodes
        self.NUM_BACKUP_HUBS = num_backup_hubs
        self.NUM_TIME_PERIODS = num_time_periods

        self.HUB_CAPACITIES = hub_capacities
        self.NODE_HUB_TIMES = node_hub_times
        self.HUB_HUB_TIMES = hub_hub_times
        self.BACKUP_HUB_STARTUP_TIMES = backup_hub_startup_times

        self.HUB_ESTABLISHMENT_COSTS = hub_establishment_costs
        self.HUB_MAINTENANCE_COSTS = hub_maintenance_costs
        self.HUB_REPAIR_COSTS = hub_repair_costs
        self.HUB_DEACTIVATION_COSTS = hub_deactivation_costs
        self.REROUTING_COSTS = rerouting_costs
        self.BACKUP_HUB_STARTUP_COSTS = backup_hub_startup_costs
        self.BACKUP_HUB_MAINTENANCE_COSTS = backup_hub_maintenance_costs
        self.HUB_FAILURE_PROBABILITY = hub_failure_probability

        self.NODE_DEMANDS = node_demands
        self.INTER_HUB_FLOW = inter_hub_flow
        self.M = M # Large constant for penalties

        self.POPULATION_SIZE = population_size
        self.MAX_ITERATIONS = max_iterations
        self.WEIGHT_Z1 = weight_z1
        self.WEIGHT_Z2 = weight_z2

        # Define the length of the individual (whale position vector)
        # x_it: NUM_HUBS * NUM_TIME_PERIODS
        # x_lit: NUM_BACKUP_HUBS * NUM_HUBS * NUM_TIME_PERIODS
        # u_it: NUM_HUBS * NUM_TIME_PERIODS
        # y_ikt: NUM_HUBS * NUM_NODES * NUM_TIME_PERIODS
        # w_ijt: NUM_HUBS * NUM_HUBS * NUM_TIME_PERIODS
        # Total length of binary decision variables
        self.DIM = (self.NUM_HUBS * self.NUM_TIME_PERIODS) + \
                   (self.NUM_BACKUP_HUBS * self.NUM_HUBS * self.NUM_TIME_PERIODS) + \
                   (self.NUM_HUBS * self.NUM_TIME_PERIODS) + \
                   (self.NUM_HUBS * self.NUM_NODES * self.NUM_TIME_PERIODS) + \
                   (self.NUM_HUBS * self.NUM_HUBS * self.NUM_TIME_PERIODS)

        self.population = self._initialize_population()
        self.best_solution = None
        self.best_fitness = float('inf')
        self.fitness_history = []

    def _initialize_population(self):
        """
        Initializes the population of whales (candidate solutions).
        Each whale's position is a binary vector representing the decision variables.
        """
        population = []
        for _ in range(self.POPULATION_SIZE):
            # Generate random binary values for all decision variables
            individual = np.random.randint(0, 2, self.DIM)
            population.append(individual)
        return np.array(population)

    def _decode_solution(self, solution):
        """
        Decodes a flat binary solution vector into the structured decision variables.
        """
        idx = 0
        # x_it: 1 if hub i is established in period t, otherwise 0
        x_it = solution[idx : idx + self.NUM_HUBS * self.NUM_TIME_PERIODS].reshape(self.NUM_HUBS, self.NUM_TIME_PERIODS)
        idx += self.NUM_HUBS * self.NUM_TIME_PERIODS

        # x_lit: 1 if hub l is assigned as a backup for hub i in period t, otherwise 0
        x_lit = solution[idx : idx + self.NUM_BACKUP_HUBS * self.NUM_HUBS * self.NUM_TIME_PERIODS].reshape(self.NUM_BACKUP_HUBS, self.NUM_HUBS, self.NUM_TIME_PERIODS)
        idx += self.NUM_BACKUP_HUBS * self.NUM_HUBS * self.NUM_TIME_PERIODS

        # u_it: 1 if hub i fails in period t, otherwise 0
        u_it = solution[idx : idx + self.NUM_HUBS * self.NUM_TIME_PERIODS].reshape(self.NUM_HUBS, self.NUM_TIME_PERIODS)
        idx += self.NUM_HUBS * self.NUM_TIME_PERIODS

        # y_ikt: 1 if node k is connected to hub i in period t, otherwise 0
        y_ikt = solution[idx : idx + self.NUM_HUBS * self.NUM_NODES * self.NUM_TIME_PERIODS].reshape(self.NUM_HUBS, self.NUM_NODES, self.NUM_TIME_PERIODS)
        idx += self.NUM_HUBS * self.NUM_NODES * self.NUM_TIME_PERIODS

        # w_ijt: 1 if hub i is connected to hub j in period t, otherwise 0
        w_ijt = solution[idx : idx + self.NUM_HUBS * self.NUM_HUBS * self.NUM_TIME_PERIODS].reshape(self.NUM_HUBS, self.NUM_HUBS, self.NUM_TIME_PERIODS)
        # idx += self.NUM_HUBS * self.NUM_HUBS * self.NUM_TIME_PERIODS # Not needed, last variable

        # Derived variables z_ik (data transfer node k to hub i) and v_ij (data transfer hub i to hub j)
        # Simplified: If connection exists and hub is active, assume full demand/flow, otherwise 0.
        # Capacity constraints will be handled as penalties.
        z_ik = np.zeros((self.NUM_HUBS, self.NUM_NODES, self.NUM_TIME_PERIODS))
        v_ij = np.zeros((self.NUM_HUBS, self.NUM_HUBS, self.NUM_TIME_PERIODS))

        for t in range(self.NUM_TIME_PERIODS):
            for i in range(self.NUM_HUBS):
                for k in range(self.NUM_NODES):
                    # If node k is connected to hub i and hub i is NOT failed
                    if y_ikt[i, k, t] == 1 and u_it[i, t] == 0:
                        z_ik[i, k, t] = self.NODE_DEMANDS[k]
                for j in range(self.NUM_HUBS):
                    # If hub i is connected to hub j and both are NOT failed
                    if w_ijt[i, j, t] == 1 and u_it[i, t] == 0 and u_it[j, t] == 0:
                        v_ij[i, j, t] = self.INTER_HUB_FLOW

        return x_it, x_lit, u_it, y_ikt, w_ijt, z_ik, v_ij

    def _calculate_fitness(self, solution):
        """
        Calculates the fitness of a solution (whale position).
        This includes calculating the two objective functions (Z1 and Z2)
        and applying penalties for constraint violations.
        """
        x_it, x_lit, u_it, y_ikt, w_ijt, z_ik, v_ij = self._decode_solution(solution)

        # --- Objective Function Z1: Minimize Transfer Time ---
        z1 = 0.0
        # Sum of Time_ij * w_ijt
        z1 += np.sum(self.HUB_HUB_TIMES[:, :, np.newaxis] * w_ijt)
        # Sum of Time_ik * y_ikt (reshaping to match dimensions)
        z1 += np.sum(self.NODE_HUB_TIMES[np.newaxis, :, :] * y_ikt.transpose(1, 0, 2)) # Transpose y_ikt to (K, I, T)
        # Sum of Rtime_l * x_lit (simplified, assuming x_lit sums over i and t for Rtime_l)
        # The paper's Z1 has sum over l, i, Rtime_l * x_lit. This implies Rtime_l is per backup hub type, not per specific hub.
        # Assuming Rtime_l is indexed by the backup hub type 'l'
        for l in range(self.NUM_BACKUP_HUBS):
            z1 += self.BACKUP_HUB_STARTUP_TIMES[l] * np.sum(x_lit[l, :, :])

        # --- Objective Function Z2: Minimize Network Cost ---
        z2 = 0.0
        # Fixed cost of hub installation: FCost_it * x_it
        z2 += np.sum(self.HUB_ESTABLISHMENT_COSTS * x_it)
        # Rerouting cost to a backup hub: RCost_lt * beta_i * x_lit
        # This term is tricky: RCost_lt is (L, T), beta_i is (I), x_lit is (L, I, T)
        # Assuming RCost_lt applies to backup hub l rerouting for any hub i
        for l in range(self.NUM_BACKUP_HUBS):
            for i in range(self.NUM_HUBS):
                for t in range(self.NUM_TIME_PERIODS):
                    z2 += self.REROUTING_COSTS[l, t] * self.HUB_FAILURE_PROBABILITY[i] * x_lit[l, i, t]
        # Maintenance cost of hub i: MiCost_it * x_it
        z2 += np.sum(self.HUB_MAINTENANCE_COSTS * x_it)
        # Deactivation cost of hub i: disCost_it * beta_i * u_it
        z2 += np.sum(self.HUB_DEACTIVATION_COSTS * self.HUB_FAILURE_PROBABILITY[:, np.newaxis] * u_it)
        # Startup cost of backup hub l: lcost_lt * x_lit
        for l in range(self.NUM_BACKUP_HUBS):
            z2 += np.sum(self.BACKUP_HUB_STARTUP_COSTS[l, np.newaxis, :] * x_lit[l, :, :])
        # Maintenance cost of backup hub l: mcost_lt * x_lit
        for l in range(self.NUM_BACKUP_HUBS):
            z2 += np.sum(self.BACKUP_HUB_MAINTENANCE_COSTS[l, np.newaxis, :] * x_lit[l, :, :])
        # Repair cost of hub i: RiCost_it * beta_i * u_it
        z2 += np.sum(self.HUB_REPAIR_COSTS * self.HUB_FAILURE_PROBABILITY[:, np.newaxis] * u_it)

        # --- Penalty for Constraint Violations ---
        penalty = 0.0

        # Constraint (4): y_ikt <= x_it (If a hub is not selected, data transfer to it is not possible)
        # If y_ikt[i, k, t] == 1 and x_it[i, t] == 0
        penalty += self.M * np.sum(np.maximum(0, y_ikt - x_it[np.newaxis, :, :].transpose(1, 0, 2))) # Transpose x_it to (I, T)

        # Constraint (5): sum_i(y_ikt) = 1 (Each node connects to only one hub)
        for k in range(self.NUM_NODES):
            for t in range(self.NUM_TIME_PERIODS):
                if np.sum(y_ikt[:, k, t]) != 1:
                    penalty += self.M

        # Constraint (6): w_ijt <= x_it (If a hub is not selected, other hubs cannot connect to it)
        # If w_ijt[i, j, t] == 1 and x_it[i, t] == 0 (hub i is source)
        penalty += self.M * np.sum(np.maximum(0, w_ijt - x_it[:, np.newaxis, :]))
        # Also, if w_ijt[i, j, t] == 1 and x_it[j, t] == 0 (hub j is destination)
        penalty += self.M * np.sum(np.maximum(0, w_ijt - x_it[np.newaxis, :, :]))


        # Constraint (7): sum_k(z_ik) <= Cap_i (Total data from nodes to hub must not exceed capacity)
        for i in range(self.NUM_HUBS):
            for t in range(self.NUM_TIME_PERIODS):
                if np.sum(z_ik[i, :, t]) > self.HUB_CAPACITIES[i]:
                    penalty += self.M * (np.sum(z_ik[i, :, t]) - self.HUB_CAPACITIES[i])

        # Constraint (8): sum_j(v_ij) <= Cap_i (Total load transferred from hubs to specific hub must not exceed capacity)
        # This means sum of incoming v_ji to hub i
        for i in range(self.NUM_HUBS):
            for t in range(self.NUM_TIME_PERIODS):
                if np.sum(v_ij[:, i, t]) > self.HUB_CAPACITIES[i]:
                    penalty += self.M * (np.sum(v_ij[:, i, t]) - self.HUB_CAPACITIES[i])

        # Constraint (9): z_ik <= M + y_ikt (If node not connected, no data transfer)
        # This is implicitly handled by z_ik derivation, but check for consistency
        # If z_ik[i, k, t] > 0 and y_ikt[i, k, t] == 0
        for i in range(self.NUM_HUBS):
            for k in range(self.NUM_NODES):
                for t in range(self.NUM_TIME_PERIODS):
                    if z_ik[i, k, t] > 0 and y_ikt[i, k, t] == 0:
                        penalty += self.M

        # Constraint (10): v_ij <= M + w_ijt (If hubs not connected, no data transfer)
        # If v_ij[i, j, t] > 0 and w_ijt[i, j, t] == 0
        for i in range(self.NUM_HUBS):
            for j in range(self.NUM_HUBS):
                for t in range(self.NUM_TIME_PERIODS):
                    if v_ij[i, j, t] > 0 and w_ijt[i, j, t] == 0:
                        penalty += self.M

        # Constraint (11): sum_l(x_lit) = x_it (Backup hub must be of type "hub" and assigned if main hub is established)
        # This means for each hub i established at time t, exactly one backup hub l must be assigned.
        # This is a strong constraint. Let's interpret it as: if x_it is 1, then sum_l(x_lit) must be 1.
        # And if x_it is 0, sum_l(x_lit) must be 0.
        for i in range(self.NUM_HUBS):
            for t in range(self.NUM_TIME_PERIODS):
                if x_it[i, t] == 1 and np.sum(x_lit[:, i, t]) != 1:
                    penalty += self.M
                if x_it[i, t] == 0 and np.sum(x_lit[:, i, t]) != 0:
                    penalty += self.M

        # Constraint (12): x_lit + x_it = 1 (At any given period, either the main hub or its backup hub can be active, but not both)
        # This is problematic. x_lit is a specific backup 'l' for hub 'i'. If multiple backups, this constraint doesn't make sense.
        # Re-interpreting: If hub i is established (x_it=1), then no backup for i (x_lit=0 for all l).
        # If hub i is NOT established (x_it=0), then *one* backup for i (sum_l x_lit = 1).
        # This implies a failure scenario. The paper's text "either the main hub or its backup hub can be active, but not both"
        # suggests this is related to a single backup being active if the main fails.
        # Let's use the interpretation from the paper's diagram: u_it (failure) implies x_lit (backup active).
        # So, if u_it is 1, then the assigned x_lit should be 1, and x_it should be 0.
        # If u_it is 0, then x_it should be 1 and x_lit should be 0.
        # This is better captured by (14) and (15), (16), (17), (18).
        # For (12), I will assume it means a hub cannot be *both* a main hub and a backup for itself or another hub at the same time.
        # Or, more simply, if a hub `i` is established (`x_it=1`), it cannot be a backup (`x_lit=1`) for itself or another hub `j`
        # if `l` refers to the index of hub `i` as a backup. This is ambiguous.
        # Let's assume it means that for a given hub `i` at time `t`, it cannot be both `x_it=1` AND `x_lit=1` for *any* `l` where `l` refers to a backup for `i`.
        # This is hard to enforce directly with the current x_lit indexing.
        # Given the ambiguity, I'll prioritize other constraints and if this becomes critical for performance, I'll revisit.
        # For now, I'll interpret it as: a hub cannot be simultaneously established AND assigned as a backup for itself.
        # This is covered by (11) and (13) and (14) if we assume `l` in `x_lit` can refer to `i`.
        # I will skip direct implementation of (12) due to its ambiguity with `x_lit`'s indexing and its overlap with other constraints,
        # unless it becomes clear how 'l' relates to 'i' in this specific constraint.

        # Constraint (13): u_it <= x_it (If a hub is not established, it cannot fail)
        # If u_it[i, t] == 1 and x_it[i, t] == 0
        penalty += self.M * np.sum(np.maximum(0, u_it - x_it))

        # Constraint (14): u_it = x_lit (If a hub fails, a backup hub must be assigned to it)
        # This implies that if u_it is 1, then exactly one x_lit for that i should be 1.
        # And if u_it is 0, then all x_lit for that i should be 0.
        for i in range(self.NUM_HUBS):
            for t in range(self.NUM_TIME_PERIODS):
                if u_it[i, t] == 1 and np.sum(x_lit[:, i, t]) != 1:
                    penalty += self.M
                if u_it[i, t] == 0 and np.sum(x_lit[:, i, t]) != 0:
                    penalty += self.M

        # Constraint (15): u_it != y_ikt (If a hub fails, nodes cannot transfer data to it)
        # If u_it[i, t] == 1 and y_ikt[i, k, t] == 1 for any k
        for i in range(self.NUM_HUBS):
            for t in range(self.NUM_TIME_PERIODS):
                if u_it[i, t] == 1 and np.sum(y_ikt[i, :, t]) > 0:
                    penalty += self.M

        # Constraint (16): u_it != w_ijt (If a hub fails, it cannot establish connections with other hubs)
        # If u_it[i, t] == 1 and (w_ijt[i, j, t] == 1 or w_ijt[j, i, t] == 1 for any j)
        for i in range(self.NUM_HUBS):
            for t in range(self.NUM_TIME_PERIODS):
                if u_it[i, t] == 1 and (np.sum(w_ijt[i, :, t]) > 0 or np.sum(w_ijt[:, i, t]) > 0):
                    penalty += self.M

        # Constraint (17): z_ik <= M + u_it (If a hub fails, data cannot be transferred via this link)
        # If u_it[i, t] == 1 and z_ik[i, k, t] > 0 for any k
        for i in range(self.NUM_HUBS):
            for k in range(self.NUM_NODES):
                for t in range(self.NUM_TIME_PERIODS):
                    if u_it[i, t] == 1 and z_ik[i, k, t] > 0:
                        penalty += self.M

        # Constraint (18): v_ij <= M + u_it (If a hub fails, data cannot be transferred via this connection)
        # If u_it[i, t] == 1 and v_ij[i, j, t] > 0 for any j (source hub fails)
        # If u_it[j, t] == 1 and v_ij[i, j, t] > 0 for any i (destination hub fails)
        for i in range(self.NUM_HUBS):
            for j in range(self.NUM_HUBS):
                for t in range(self.NUM_TIME_PERIODS):
                    if (u_it[i, t] == 1 or u_it[j, t] == 1) and v_ij[i, j, t] > 0:
                        penalty += self.M

        # Combine objectives with weights and add penalty
        total_fitness = (self.WEIGHT_Z1 * z1) + (self.WEIGHT_Z2 * z2) + penalty
        return total_fitness, z1, z2

    def _update_best_solution(self):
        """
        Updates the global best solution found so far.
        """
        for i in range(self.POPULATION_SIZE):
            current_fitness, _, _ = self._calculate_fitness(self.population[i])
            if current_fitness < self.best_fitness:
                self.best_fitness = current_fitness
                self.best_solution = np.copy(self.population[i])

    def optimize(self):
        """
        Runs the Whale Optimization Algorithm.
        """
        print("Starting Whale Optimization Algorithm...")
        for t in range(self.MAX_ITERATIONS):
            # Update a, A, C, l, p for each iteration
            a = 2 - t * (2 / self.MAX_ITERATIONS) # 'a' decreases linearly from 2 to 0
            
            # Update best solution for current iteration
            self._update_best_solution()

            for i in range(self.POPULATION_SIZE):
                r1, r2 = random.random(), random.random()
                A = 2 * a * r1 - a # Coefficient vector A
                C = 2 * r2 # Coefficient vector C
                l = (a - 1) * random.random() + 1 # 'l' is a random number in [-1, 1]
                p = random.random() # 'p' is a random number in [0, 1]

                current_position = self.population[i]
                best_position = self.best_solution

                if best_position is None: # Handle case where best_solution is not yet set
                    best_position = current_position # Fallback to current position for first iteration

                # Calculate D for the current whale
                D_abs = np.abs(C * best_position - current_position)

                if p < 0.5:
                    if np.abs(A) < 1:
                        # Shrinking Encircling Prey (Exploitation)
                        new_position = best_position - A * D_abs
                    else:
                        # Search for Prey (Exploration)
                        random_whale_idx = random.randint(0, self.POPULATION_SIZE - 1)
                        X_rand = self.population[random_whale_idx]
                        D_rand = np.abs(C * X_rand - current_position)
                        new_position = X_rand - A * D_rand
                else:
                    # Spiral Updating Position (Exploitation)
                    D_prime = np.abs(best_position - current_position) # Distance of the i-th whale to the best solution
                    new_position = D_prime * np.exp(l * pi) * cos(2 * pi * l) + best_position

                # Apply binary transformation (sigmoid function and threshold)
                # Ensure new_position is within [0, 1] range before binarization
                # This is a common approach for binary WOA
                sigmoid_transformed_position = 1 / (1 + np.exp(-new_position))
                self.population[i] = (sigmoid_transformed_position > random.random()).astype(int)

            current_best_fitness, current_z1, current_z2 = self._calculate_fitness(self.best_solution)
            self.fitness_history.append(current_best_fitness)

            if t % 10 == 0 or t == self.MAX_ITERATIONS - 1:
                print(f"Iteration {t+1}/{self.MAX_ITERATIONS}, Best Fitness: {current_best_fitness:.2f}, Z1: {current_z1:.2f}, Z2: {current_z2:.2f}")

        print("\nOptimization Finished.")
        print(f"Final Best Fitness: {self.best_fitness:.2f}")
        final_z1, final_z2 = self._calculate_fitness(self.best_solution)[1:]
        print(f"Final Z1 (Time): {final_z1:.2f}")
        print(f"Final Z2 (Cost): {final_z2:.2f}")

        # Decode and print the best solution's decision variables
        print("\nOptimal Decision Variables:")
        x_it, x_lit, u_it, y_ikt, w_ijt, z_ik, v_ij = self._decode_solution(self.best_solution)

        print("\nx_it (Hub Established):")
        print(x_it)
        print("\nx_lit (Backup Hub Assigned):")
        print(x_lit)
        print("\nu_it (Hub Failed):")
        print(u_it)
        print("\ny_ikt (Node-Hub Assignment):")
        print(y_ikt)
        print("\nw_ijt (Hub-Hub Connectivity):")
        print(w_ijt)
        print("\nz_ik (Node-Hub Data Transfer):")
        print(z_ik)
        print("\nv_ij (Hub-Hub Data Transfer):")
        print(v_ij)

        return self.best_solution, self.best_fitness, self.fitness_history
